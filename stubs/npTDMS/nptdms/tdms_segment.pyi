from _typeshed import Incomplete
from collections.abc import Generator

from nptdms.base_segment import BaseDataReader, BaseSegmentObject

log: Incomplete
RAW_DATA_INDEX_NO_DATA: int
RAW_DATA_INDEX_MATCHES_PREVIOUS: int

class TdmsSegment:
    position: Incomplete
    toc_mask: Incomplete
    next_segment_pos: Incomplete
    data_position: Incomplete
    num_chunks: int
    final_chunk_lengths_override: Incomplete
    ordered_objects: Incomplete
    object_index: Incomplete
    def __init__(self, position, toc_mask, next_segment_pos, data_position) -> None: ...
    def read_segment_objects(self, file, previous_segment_objects, index_cache, previous_segment, segment_incomplete): ...
    def get_segment_object(self, object_path): ...
    def read_raw_data(self, f) -> Generator[Incomplete, None, None]: ...
    def read_raw_data_for_channel(
        self, f, channel_path, chunk_offset: int = ..., num_chunks: Incomplete | None = ...
    ) -> Generator[Incomplete, None, None]: ...

class InterleavedDataReader(BaseDataReader):
    def read_data_chunks(self, file, data_objects, num_chunks): ...
    def read_channel_data_chunks(self, file, data_objects, channel_path, chunk_offset, stop_chunk): ...

class ContiguousDataReader(BaseDataReader): ...

class TdmsSegmentObject(BaseSegmentObject):
    number_values: Incomplete
    data_type: Incomplete
    data_size: Incomplete
    def read_raw_data_index(self, f, raw_data_index_header, endianness) -> None: ...
    def read_values(self, file, number_values, endianness): ...
    def new_segment_data(self): ...

class SegmentIndexCache:
    def __init__(self) -> None: ...
    def get_index(self, object_list): ...

class ObjectListKey:
    objects: Incomplete
    def __init__(self, objects) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...

def read_property(f, endianness: str = ...): ...
